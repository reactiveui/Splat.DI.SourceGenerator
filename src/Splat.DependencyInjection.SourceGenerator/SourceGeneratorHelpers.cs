// Copyright (c) 2019-2021 ReactiveUI Association Incorporated. All rights reserved.
// ReactiveUI Association Incorporated licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Linq;

using Microsoft.CodeAnalysis;

using Splat.DependencyInjection.SourceGenerator.Metadata;

namespace Splat.DependencyInjection.SourceGenerator;

internal static class SourceGeneratorHelpers
{

    public static string Generate(GeneratorExecutionContext context, Compilation compilation, SyntaxReceiver syntaxReceiver)
    {
        return Generate(new GeneratorExecutionContextAdapter(context), compilation, syntaxReceiver);
    }

    public static string Generate(IGeneratorContext context, Compilation compilation, SyntaxReceiver syntaxReceiver)
    {
        var methods = MetadataExtractor.GetValidMethods(context, syntaxReceiver, compilation).ToList();

        methods = MetadataDependencyChecker.CheckMetadata(context, methods);

        // Generate using simplified string-based approach instead of Roslyn syntax trees
        return GenerateStringBased(methods);
    }

    /// <summary>
    /// Generate code using string templates instead of Roslyn syntax trees.
    /// </summary>
    private static string GenerateStringBased(IEnumerable<MethodMetadata> methods)
    {
        var statements = new List<string>();

        foreach (var method in methods)
        {
            var constructorArgs = method.ConstructorDependencies
                .Select(dep => $"{Constants.ResolverParameterName}.{Constants.LocatorGetService}<{dep.TypeName}>()")
                .ToList();

            var contract = method.RegisterParameterValues.FirstOrDefault(p => p.ParameterName == "contract")?.ParameterValue;

            string objectCreation;
            if (method.Properties.Any())
            {
                var propertyInits = method.Properties
                    .Select(prop => $"{prop.PropertyName} = {Constants.ResolverParameterName}.{Constants.LocatorGetService}<{prop.TypeName}>()")
                    .ToList();

                objectCreation = constructorArgs.Any()
                    ? $"new {method.ConcreteTypeName}({string.Join(", ", constructorArgs)}) {{ {string.Join(", ", propertyInits)} }}"
                    : $"new {method.ConcreteTypeName}() {{ {string.Join(", ", propertyInits)} }}";
            }
            else
            {
                objectCreation = $"new {method.ConcreteTypeName}({string.Join(", ", constructorArgs)})";
            }

            string statement = method switch
            {
                RegisterLazySingletonMetadata lazyMetadata => GenerateLazyStatement(lazyMetadata, objectCreation, contract),
                RegisterMetadata registerMetadata => GenerateRegisterStatement(registerMetadata, objectCreation, contract),
                RegisterConstantMetadata constantMetadata => GenerateConstantStatement(constantMetadata),
                _ => string.Empty
            };

            if (!string.IsNullOrEmpty(statement))
            {
                statements.Add($"            {statement}");
            }
        }

        if (!statements.Any())
        {
            return string.Empty;
        }

        return $$"""
            // <auto-generated />
            namespace {{Constants.NamespaceName}}
            {
                internal static partial class {{Constants.ClassName}}
                {
                    static partial void {{Constants.IocMethod}}({{Constants.ResolverType}} {{Constants.ResolverParameterName}})
                    {
            {{string.Join("\n", statements)}}
                    }
                }
            }
            """;
    }

    private static string GenerateLazyStatement(RegisterLazySingletonMetadata metadata, string objectCreation, string? contract)
    {
        var lazyModeParam = metadata.RegisterParameterValues.FirstOrDefault(p => p.ParameterName == "mode");
        var lazyMode = lazyModeParam?.ParameterValue ?? "System.Threading.LazyThreadSafetyMode.ExecutionAndPublication";

        var lazyCreation = $"new System.Lazy<{metadata.InterfaceTypeName}>(() => {objectCreation}, {lazyMode})";

        return contract is null
            ? $"{Constants.ResolverParameterName}.RegisterLazySingleton<{metadata.InterfaceTypeName}>(() => {lazyCreation}.Value);"
            : $"{Constants.ResolverParameterName}.RegisterLazySingleton<{metadata.InterfaceTypeName}>(() => {lazyCreation}.Value, \"{contract}\");";
    }

    private static string GenerateRegisterStatement(RegisterMetadata metadata, string objectCreation, string? contract)
    {
        return contract is null
            ? $"{Constants.ResolverParameterName}.Register<{metadata.InterfaceTypeName}>(() => {objectCreation});"
            : $"{Constants.ResolverParameterName}.Register<{metadata.InterfaceTypeName}>(() => {objectCreation}, \"{contract}\");";
    }

    private static string GenerateConstantStatement(RegisterConstantMetadata metadata)
    {
        // For RegisterConstant, the value is already provided by the user call
        // This is handled differently in the original implementation
        return string.Empty;
    }
}
