// Copyright (c) 2019-2026 ReactiveUI Association Incorporated. All rights reserved.
// ReactiveUI Association Incorporated licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System.Reflection;

namespace Splat.DependencyInjection.SourceGenerator;

internal static class Constants
{
    public const string ClassName = "SplatRegistrations";
    public const string NamespaceName = "Splat";
    public const string LocatorGetService = "GetService";

    public const string ConstructorAttribute = "global::Splat.DependencyInjectionConstructorAttribute";
    public const string PropertyAttribute = "global::Splat.DependencyInjectionPropertyAttribute";

    public const string ResolverType = "Splat.IDependencyResolver";
    public const string ResolverParameterName = "resolver";

    public const string IocMethod = "SetupIOCInternal";

    private static readonly AssemblyName _assemblyName = typeof(Constants).Assembly.GetName();

    public static string ExtensionMethodText => $$"""
        // <auto-generated/>

        #nullable enable annotations
        #nullable disable warnings

        // Suppress warnings about [Obsolete] member usage in generated code.
        #pragma warning disable CS0612, CS0618

        namespace {{NamespaceName}}
        {
            /// <summary>
            /// Extension methods for the Splat DI source generator.
            /// </summary>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{_assemblyName.Name}}", "{{_assemblyName.Version}}")]
            internal static partial class {{ClassName}}
            {
                /// <summary>
                /// Registers a class with its concrete class.
                /// </summary>
                public static void Register<TInterface, TConcrete>()
                {
                }

                /// <summary>
                /// Registers a class with its concrete class.
                /// </summary>
                /// <param name="contract">Optional contract.</param>
                public static void Register<TInterface, TConcrete>(string contract)
                {
                }

                /// <summary>
                /// Registers a class with its concrete class.
                /// </summary>
                public static void RegisterLazySingleton<TInterface, TConcrete>()
                {
                }

                /// <summary>
                /// Registers a class with its concrete class.
                /// </summary>
                /// <param name="mode">The threading mode.</param>
                public static void RegisterLazySingleton<TInterface, TConcrete>(System.Threading.LazyThreadSafetyMode mode)
                {
                }

                /// <summary>
                /// Registers a class with its concrete class.
                /// </summary>
                /// <param name="contract">Optional contract.</param>
                public static void RegisterLazySingleton<TInterface, TConcrete>(string contract)
                {
                }

                /// <summary>
                /// Registers a class with its concrete class.
                /// </summary>
                /// <param name="contract">Optional contract.</param>
                /// <param name="mode">The threading mode.</param>
                public static void RegisterLazySingleton<TInterface, TConcrete>(string contract, System.Threading.LazyThreadSafetyMode mode)
                {
                }

                /// <summary>
                /// Registers a class with its concrete class.
                /// </summary>
                public static void Register<T>()
                {
                }


                /// <summary>
                /// Registers a class with its concrete class.
                /// </summary>
                /// <param name="contract">Optional contract.</param>
                public static void Register<T>(string contract)
                {
                }

                /// <summary>
                /// Registers a lazy class with its concrete class.
                /// </summary>
                public static void RegisterLazySingleton<T>()
                {
                }


                /// <summary>
                /// Registers a lazy class with its concrete class.
                /// </summary>
                /// <param name="contract">Optional contract.</param>
                public static void RegisterLazySingleton<T>(string contract)
                {
                }

                /// <summary>
                /// Proxy for the Splat SetService.
                /// </summary>
                public static void RegisterConstant<T>(T instance) => Splat.Locator.CurrentMutable.RegisterConstant<T>(instance);

                /// <summary>
                /// Proxy for the Splat SetService.
                /// </summary>
                /// <param name="contract">Optional contract.</param>
                public static void RegisterConstant<T>(T instance, string contract) => Splat.Locator.CurrentMutable.RegisterConstant<T>(instance, contract);

                /// <summary>
                /// Registers the registrations.
                /// </summary>
                public static void SetupIOC()
                {
                    SetupIOCInternal(Splat.Locator.GetLocator());
                }

                /// <summary>
                /// Registers the registrations.
                /// </summary>
                /// <param name="resolver">The resolver to register with.</param>
                public static void SetupIOC(Splat.IDependencyResolver resolver)
                {
                    SetupIOCInternal(resolver);
                }


                static partial void SetupIOCInternal(Splat.IDependencyResolver resolver);

                /// <summary>
                /// Makes the property get added by the DI engine.
                /// </summary>
                [System.AttributeUsage(System.AttributeTargets.Property), Microsoft.CodeAnalysis.Embedded]
                internal sealed class DependencyInjectionPropertyAttribute : System.Attribute
                {
                }

                /// <summary>
                /// Makes this the constructor used by the DI engine.
                /// </summary>
                [System.AttributeUsage(System.AttributeTargets.Constructor), Microsoft.CodeAnalysis.Embedded]
                internal sealed class DependencyInjectionConstructorAttribute : System.Attribute
                {
                }
            }
        }
        """;

    // EmbeddedAttribute definition - prevents conflicts with InternalsVisibleTo
    public static string EmbeddedAttributeText => $$"""
        // <auto-generated/>

        #nullable enable annotations
        #nullable disable warnings

        // Suppress warnings about [Obsolete] member usage in generated code.
        #pragma warning disable CS0612, CS0618

        namespace Microsoft.CodeAnalysis
        {
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{_assemblyName.Name}}", "{{_assemblyName.Version}}")]
            [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Interface | System.AttributeTargets.Delegate, AllowMultiple = false, Inherited = false)]
            [System.Diagnostics.Conditional("NEVER_DEFINED")]
            internal sealed class EmbeddedAttribute : System.Attribute
            {
            }
        }
        """;
}
