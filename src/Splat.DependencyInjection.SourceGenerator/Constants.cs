// Copyright (c) 2019-2026 ReactiveUI Association Incorporated. All rights reserved.
// ReactiveUI Association Incorporated licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System.Reflection;

namespace Splat.DependencyInjection.SourceGenerator;

internal static class Constants
{
    public const string ClassName = "SplatRegistrations";
    public const string NamespaceName = "Splat";
    public const string LocatorGetService = "GetService";

    public const string ConstructorAttribute = "global::Splat.DependencyInjectionConstructorAttribute";
    public const string PropertyAttribute = "global::Splat.DependencyInjectionPropertyAttribute";

    public const string ConstructorAttributeMetadataName = "Splat.DependencyInjectionConstructorAttribute";
    public const string PropertyAttributeMetadataName = "Splat.DependencyInjectionPropertyAttribute";
    public const string ConstructorAttributeShortName = "DependencyInjectionConstructor";

    public const string ResolverType = "Splat.IDependencyResolver";
    public const string ResolverParameterName = "resolver";

    public const string IocMethod = "SetupIOCInternal";

    public const string MethodNameRegister = "Register";
    public const string MethodNameRegisterLazySingleton = "RegisterLazySingleton";

    public const string ParameterNameContract = "contract";
    public const string ParameterNameMode = "mode";

    public const string LazyOpenGenericTypeName = "global::System.Lazy<T>";
    public const string LazyMetadataName = "System.Lazy`1";
    public const string EnumerableOpenGenericTypeName = "global::System.Collections.Generic.IEnumerable<T>";
    public const string EnumerableMetadataName = "System.Collections.Generic.IEnumerable`1";

    public const string EmbeddedAttributeFileName = "Microsoft.CodeAnalysis.EmbeddedAttribute.g.cs";
    public const string ExtensionMethodFileName = "Splat.DI.g.cs";
    public const string RegistrationFileName = "Splat.DI.Reg.g.cs";

    private static readonly AssemblyName _assemblyName = typeof(Constants).Assembly.GetName();

    public static string ExtensionMethodText => $$"""
        // <auto-generated/>

        #nullable enable annotations
        #nullable disable warnings

        // Suppress warnings about [Obsolete] member usage in generated code.
        #pragma warning disable CS0612, CS0618

        namespace {{NamespaceName}}
        {
            /// <summary>
            /// Provides extension methods for the Splat dependency injection source generator.
            /// This class contains marker methods that are analyzed at compile-time to generate
            /// dependency injection registrations.
            /// </summary>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{_assemblyName.Name}}", "{{_assemblyName.Version}}")]
            internal static partial class {{ClassName}}
            {
                /// <summary>
                /// Registers a transient dependency mapping from <typeparamref name="TInterface"/> to <typeparamref name="TConcrete"/>.
                /// A new instance of <typeparamref name="TConcrete"/> will be created each time <typeparamref name="TInterface"/> is resolved.
                /// </summary>
                /// <typeparam name="TInterface">The interface or base type to register.</typeparam>
                /// <typeparam name="TConcrete">The concrete type that implements <typeparamref name="TInterface"/>.</typeparam>
                public static void Register<TInterface, TConcrete>()
                {
                }

                /// <summary>
                /// Registers a transient dependency mapping from <typeparamref name="TInterface"/> to <typeparamref name="TConcrete"/> with a contract.
                /// A new instance of <typeparamref name="TConcrete"/> will be created each time <typeparamref name="TInterface"/> is resolved with the specified contract.
                /// </summary>
                /// <typeparam name="TInterface">The interface or base type to register.</typeparam>
                /// <typeparam name="TConcrete">The concrete type that implements <typeparamref name="TInterface"/>.</typeparam>
                /// <param name="contract">A unique string identifier to distinguish between multiple registrations of the same type.</param>
                public static void Register<TInterface, TConcrete>(string contract)
                {
                }

                /// <summary>
                /// Registers a lazy singleton dependency mapping from <typeparamref name="TInterface"/> to <typeparamref name="TConcrete"/>.
                /// A single instance of <typeparamref name="TConcrete"/> will be created on first resolution and reused for all subsequent resolutions.
                /// </summary>
                /// <typeparam name="TInterface">The interface or base type to register.</typeparam>
                /// <typeparam name="TConcrete">The concrete type that implements <typeparamref name="TInterface"/>.</typeparam>
                public static void RegisterLazySingleton<TInterface, TConcrete>()
                {
                }

                /// <summary>
                /// Registers a lazy singleton dependency mapping from <typeparamref name="TInterface"/> to <typeparamref name="TConcrete"/> with specified thread safety mode.
                /// A single instance of <typeparamref name="TConcrete"/> will be created on first resolution and reused for all subsequent resolutions.
                /// </summary>
                /// <typeparam name="TInterface">The interface or base type to register.</typeparam>
                /// <typeparam name="TConcrete">The concrete type that implements <typeparamref name="TInterface"/>.</typeparam>
                /// <param name="mode">The <see cref="System.Threading.LazyThreadSafetyMode"/> specifying how the singleton should be initialized in multi-threaded scenarios.</param>
                public static void RegisterLazySingleton<TInterface, TConcrete>(System.Threading.LazyThreadSafetyMode mode)
                {
                }

                /// <summary>
                /// Registers a lazy singleton dependency mapping from <typeparamref name="TInterface"/> to <typeparamref name="TConcrete"/> with a contract.
                /// A single instance of <typeparamref name="TConcrete"/> will be created on first resolution and reused for all subsequent resolutions.
                /// </summary>
                /// <typeparam name="TInterface">The interface or base type to register.</typeparam>
                /// <typeparam name="TConcrete">The concrete type that implements <typeparamref name="TInterface"/>.</typeparam>
                /// <param name="contract">A unique string identifier to distinguish between multiple registrations of the same type.</param>
                public static void RegisterLazySingleton<TInterface, TConcrete>(string contract)
                {
                }

                /// <summary>
                /// Registers a lazy singleton dependency mapping from <typeparamref name="TInterface"/> to <typeparamref name="TConcrete"/> with a contract and specified thread safety mode.
                /// A single instance of <typeparamref name="TConcrete"/> will be created on first resolution and reused for all subsequent resolutions.
                /// </summary>
                /// <typeparam name="TInterface">The interface or base type to register.</typeparam>
                /// <typeparam name="TConcrete">The concrete type that implements <typeparamref name="TInterface"/>.</typeparam>
                /// <param name="contract">A unique string identifier to distinguish between multiple registrations of the same type.</param>
                /// <param name="mode">The <see cref="System.Threading.LazyThreadSafetyMode"/> specifying how the singleton should be initialized in multi-threaded scenarios.</param>
                public static void RegisterLazySingleton<TInterface, TConcrete>(string contract, System.Threading.LazyThreadSafetyMode mode)
                {
                }

                /// <summary>
                /// Registers a transient dependency for type <typeparamref name="T"/>.
                /// A new instance of <typeparamref name="T"/> will be created each time it is resolved.
                /// </summary>
                /// <typeparam name="T">The type to register.</typeparam>
                public static void Register<T>()
                {
                }


                /// <summary>
                /// Registers a transient dependency for type <typeparamref name="T"/> with a contract.
                /// A new instance of <typeparamref name="T"/> will be created each time it is resolved with the specified contract.
                /// </summary>
                /// <typeparam name="T">The type to register.</typeparam>
                /// <param name="contract">A unique string identifier to distinguish between multiple registrations of the same type.</param>
                public static void Register<T>(string contract)
                {
                }

                /// <summary>
                /// Registers a lazy singleton dependency for type <typeparamref name="T"/>.
                /// A single instance of <typeparamref name="T"/> will be created on first resolution and reused for all subsequent resolutions.
                /// </summary>
                /// <typeparam name="T">The type to register.</typeparam>
                public static void RegisterLazySingleton<T>()
                {
                }


                /// <summary>
                /// Registers a lazy singleton dependency for type <typeparamref name="T"/> with a contract.
                /// A single instance of <typeparamref name="T"/> will be created on first resolution and reused for all subsequent resolutions.
                /// </summary>
                /// <typeparam name="T">The type to register.</typeparam>
                /// <param name="contract">A unique string identifier to distinguish between multiple registrations of the same type.</param>
                public static void RegisterLazySingleton<T>(string contract)
                {
                }

                /// <summary>
                /// Registers a constant (singleton) instance of type <typeparamref name="T"/> with the dependency resolver.
                /// This method is a proxy for <see cref="Splat.IMutableDependencyResolver.RegisterConstant{T}(T, string?)"/>.
                /// </summary>
                /// <typeparam name="T">The type of the instance to register. Must be a reference type.</typeparam>
                /// <param name="instance">The instance to register as a constant.</param>
                public static void RegisterConstant<T>(T instance) where T : class => Splat.Locator.CurrentMutable.RegisterConstant<T>(instance);

                /// <summary>
                /// Registers a constant (singleton) instance of type <typeparamref name="T"/> with the dependency resolver using a contract.
                /// This method is a proxy for <see cref="Splat.IMutableDependencyResolver.RegisterConstant{T}(T, string?)"/>.
                /// </summary>
                /// <typeparam name="T">The type of the instance to register. Must be a reference type.</typeparam>
                /// <param name="instance">The instance to register as a constant.</param>
                /// <param name="contract">A unique string identifier to distinguish between multiple registrations of the same type.</param>
                public static void RegisterConstant<T>(T instance, string contract) where T : class => Splat.Locator.CurrentMutable.RegisterConstant<T>(instance, contract);

                /// <summary>
                /// Initializes the dependency injection container by registering all dependencies with the default <see cref="Splat.Locator"/>.
                /// This method should be called once during application startup after all registration calls have been made.
                /// </summary>
                public static void SetupIOC()
                {
                    SetupIOCInternal(Splat.Locator.GetLocator());
                }

                /// <summary>
                /// Initializes the dependency injection container by registering all dependencies with the specified resolver.
                /// This method should be called once during application startup after all registration calls have been made.
                /// </summary>
                /// <param name="resolver">The <see cref="Splat.IDependencyResolver"/> instance to register dependencies with.</param>
                public static void SetupIOC(Splat.IDependencyResolver resolver)
                {
                    SetupIOCInternal(resolver);
                }


                static partial void SetupIOCInternal(Splat.IDependencyResolver resolver);
            }

            /// <summary>
            /// Marks a property to be injected by the dependency injection engine.
            /// Properties marked with this attribute will have their values automatically
            /// resolved and set by the DI container during object construction.
            /// </summary>
            /// <remarks>
            /// The property must have an accessible setter (public, internal, or internal protected).
            /// The property type must be registered in the DI container, or resolution will fail at runtime.
            /// </remarks>
            [System.AttributeUsage(System.AttributeTargets.Property), Microsoft.CodeAnalysis.Embedded]
            internal sealed class DependencyInjectionPropertyAttribute : System.Attribute
            {
            }

            /// <summary>
            /// Marks a constructor as the preferred constructor for dependency injection.
            /// When a class has multiple constructors, this attribute specifies which constructor
            /// the DI engine should use for object construction.
            /// </summary>
            /// <remarks>
            /// Only one constructor per class should be marked with this attribute.
            /// If multiple constructors exist without this attribute, the analyzer will generate
            /// diagnostic warning SPLATDI001.
            /// The constructor must be accessible (public, internal, or internal protected).
            /// </remarks>
            [System.AttributeUsage(System.AttributeTargets.Constructor), Microsoft.CodeAnalysis.Embedded]
            internal sealed class DependencyInjectionConstructorAttribute : System.Attribute
            {
            }
        }
        """;

    // EmbeddedAttribute definition - prevents conflicts with InternalsVisibleTo
    public static string EmbeddedAttributeText => $$"""
        // <auto-generated/>

        #nullable enable annotations
        #nullable disable warnings

        // Suppress warnings about [Obsolete] member usage in generated code.
        #pragma warning disable CS0612, CS0618

        namespace Microsoft.CodeAnalysis
        {
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{_assemblyName.Name}}", "{{_assemblyName.Version}}")]
            [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Enum | System.AttributeTargets.Interface | System.AttributeTargets.Delegate, AllowMultiple = false, Inherited = false)]
            [System.Diagnostics.Conditional("NEVER_DEFINED")]
            internal sealed class EmbeddedAttribute : System.Attribute
            {
            }
        }
        """;
}
