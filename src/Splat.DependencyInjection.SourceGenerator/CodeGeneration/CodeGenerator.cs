// Copyright (c) 2019-2026 ReactiveUI Association Incorporated. All rights reserved.
// ReactiveUI Association Incorporated licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System.Collections.Immutable;
using System.Reflection;
using System.Text;
using Splat.DependencyInjection.SourceGenerator.Models;

namespace Splat.DependencyInjection.SourceGenerator.CodeGeneration;

/// <summary>
/// Handles string-based code generation for Splat DI.
/// </summary>
internal static class CodeGenerator
{
    private static readonly AssemblyName _assemblyName = typeof(Generator).Assembly.GetName();

    /// <summary>
    /// Generates the SetupIOCInternal method.
    /// </summary>
    /// <param name="transients">The transient registrations.</param>
    /// <param name="lazySingletons">The lazy singleton registrations.</param>
    /// <returns>The generated source code.</returns>
    internal static string GenerateSetupIOCMethod(
        ImmutableArray<TransientRegistrationInfo> transients,
        ImmutableArray<LazySingletonRegistrationInfo> lazySingletons)
    {
        var sb = new StringBuilder();

        sb.Append($$"""
            // <auto-generated/>

            #nullable enable annotations
            #nullable disable warnings

            // Suppress warnings about [Obsolete] member usage in generated code.
            #pragma warning disable CS0612, CS0618

            namespace Splat
            {
                [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{_assemblyName.Name}}", "{{_assemblyName.Version}}")]
                internal static partial class SplatRegistrations
                {
                    static partial void SetupIOCInternal(Splat.IDependencyResolver resolver)
                    {
            """);

        foreach (var registration in transients)
        {
            sb.AppendLine();
            GenerateTransientRegistration(sb, registration);
        }

        foreach (var registration in lazySingletons)
        {
            sb.AppendLine();
            GenerateLazySingletonRegistration(sb, registration);
        }

        sb.Append("""
                    }
                }
            }
            """);

        return sb.ToString();
    }

    /// <summary>
    /// Generates a transient registration.
    /// </summary>
    /// <param name="sb">The string builder to append to.</param>
    /// <param name="registration">The registration information.</param>
    internal static void GenerateTransientRegistration(
        StringBuilder sb,
        TransientRegistrationInfo registration)
    {
        var constructorArgs = GetConstructorArguments(registration.ConstructorParameters, registration.ContractValue);
        var propertyInitializer = GetPropertyInitializer(registration.PropertyInjections, registration.ContractValue);
        var contractArg = registration.ContractValue is not null ? $", {registration.ContractValue}" : string.Empty;

        sb.Append($"            resolver.Register<{registration.InterfaceTypeFullName}>(() => new {registration.ConcreteTypeFullName}({constructorArgs}){propertyInitializer}{contractArg});");
    }

    /// <summary>
    /// Generates a lazy singleton registration.
    /// </summary>
    /// <param name="sb">The string builder to append to.</param>
    /// <param name="registration">The registration information.</param>
    internal static void GenerateLazySingletonRegistration(
        StringBuilder sb,
        LazySingletonRegistrationInfo registration)
    {
        var constructorArgs = GetConstructorArguments(registration.ConstructorParameters, registration.ContractValue);
        var propertyInitializer = GetPropertyInitializer(registration.PropertyInjections, registration.ContractValue);
        var lazyTypeFullName = $"global::System.Lazy<{registration.InterfaceTypeFullName}>";
        var lazyModeArg = registration.LazyThreadSafetyMode is not null ? $", {registration.LazyThreadSafetyMode}" : string.Empty;
        var contractArg = registration.ContractValue is not null ? $", {registration.ContractValue}" : string.Empty;

        sb.Append($$"""
                        {
                            {{lazyTypeFullName}} lazy = new {{lazyTypeFullName}}(() => new {{registration.ConcreteTypeFullName}}({{constructorArgs}}){{propertyInitializer}}{{lazyModeArg}});
                            resolver.Register<{{lazyTypeFullName}}>(() => lazy{{contractArg}});
                            resolver.Register<{{registration.InterfaceTypeFullName}}>(() => lazy.Value{{contractArg}});
                        }
            """);
    }

    private static string GetConstructorArguments(EquatableArray<ConstructorParameter> parameters, string? contractValue)
    {
        if (parameters.Length == 0)
        {
            return string.Empty;
        }

        var args = new string[parameters.Length];
        for (var i = 0; i < parameters.Length; i++)
        {
            var p = parameters[i];
            args[i] = GetResolutionString(p.TypeFullName, p.IsCollection, p.CollectionItemType, contractValue);
        }

        return string.Join(", ", args);
    }

    private static string GetPropertyInitializer(EquatableArray<PropertyInjection> properties, string? contractValue)
    {
        if (properties.Length == 0)
        {
            return string.Empty;
        }

        var props = new string[properties.Length];
        for (var i = 0; i < properties.Length; i++)
        {
            var p = properties[i];
            var resolution = GetResolutionString(p.TypeFullName, false, null, contractValue);
            props[i] = $"{p.PropertyName} = {resolution}";
        }

        return $" {{ {string.Join(", ", props)} }}";
    }

    private static string GetResolutionString(string typeFullName, bool isCollection, string? collectionItemType, string? contractValue)
    {
        if (isCollection && collectionItemType is not null)
        {
            return contractValue is not null
                ? $"resolver.GetServices<{collectionItemType}>({contractValue})"
                : $"resolver.GetServices<{collectionItemType}>()";
        }

        if (contractValue is not null)
        {
            return $"resolver.GetService<{typeFullName}>({contractValue}) ?? throw new global::System.InvalidOperationException(\"Dependency '{typeFullName}' with contract \" + {contractValue} + \" not registered with Splat resolver.\")";
        }

        return $"resolver.GetService<{typeFullName}>() ?? throw new global::System.InvalidOperationException(\"Dependency '{typeFullName}' not registered with Splat resolver.\")";
    }
}
