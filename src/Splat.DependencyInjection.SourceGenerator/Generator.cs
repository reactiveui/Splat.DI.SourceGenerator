// Copyright (c) 2019-2026 ReactiveUI Association Incorporated. All rights reserved.
// ReactiveUI Association Incorporated licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using Splat.DependencyInjection.SourceGenerator.Models;

namespace Splat.DependencyInjection.SourceGenerator;

/// <summary>
/// Incremental generator for Splat dependency injection registrations.
/// </summary>
[Generator]
public class Generator : IIncrementalGenerator
{
    private static readonly SymbolDisplayFormat _fullyQualifiedFormat = SymbolDisplayFormat.FullyQualifiedFormat;
    private static readonly AssemblyName _assemblyName = typeof(Generator).Assembly.GetName();

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Always emit attributes and marker methods (per Cookbook best practices)
        context.RegisterPostInitializationOutput(ctx =>
        {
            // Emit EmbeddedAttribute first to avoid conflicts with InternalsVisibleTo
            ctx.AddSource(
                "Microsoft.CodeAnalysis.EmbeddedAttribute.g.cs",
                SourceText.From(Constants.EmbeddedAttributeText, Encoding.UTF8));

            // Emit marker attributes and extension methods
            ctx.AddSource(
                "Splat.DI.g.cs",
                SourceText.From(Constants.ExtensionMethodText, Encoding.UTF8));
        });

        // Pipeline 1: Register<TInterface, TConcrete>() calls
        var registerCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: RoslynHelpers.IsRegisterInvocation,
                transform: ExtractRegisterMetadata)
            .Where(x => x is not null)
            .Select((x, _) => x!);

        // Pipeline 2: RegisterLazySingleton<TInterface, TConcrete>() calls
        var lazySingletonCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: RoslynHelpers.IsRegisterLazySingletonInvocation,
                transform: ExtractLazySingletonMetadata)
            .Where(x => x is not null)
            .Select((x, _) => x!);

        // Combine all registrations
        var allRegistrations = registerCalls
            .Collect()
            .Combine(lazySingletonCalls.Collect());

        // Generate output with validation
        context.RegisterSourceOutput(allRegistrations, GenerateCode);
    }

    internal static void GenerateCode(
        SourceProductionContext context,
        (ImmutableArray<TransientRegistrationInfo> Transients, ImmutableArray<LazySingletonRegistrationInfo> LazySingletons) data)
    {
        var (transients, lazySingletons) = data;

        // Generate code only for valid registrations (invalid ones were filtered out in transform)
        var code = GenerateSetupIOCMethod(transients, lazySingletons);
        context.AddSource("Splat.DI.Reg.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    internal static string GenerateSetupIOCMethod(
        ImmutableArray<TransientRegistrationInfo> transients,
        ImmutableArray<LazySingletonRegistrationInfo> lazySingletons)
    {
        // Estimate: ~200 chars header + ~150 chars per registration
        var estimatedCapacity = 200 + ((transients.Length + lazySingletons.Length) * 150);
        var sb = new StringBuilder(estimatedCapacity)
            .AppendLine("// <auto-generated/>")
            .AppendLine()
            .AppendLine("#nullable enable annotations")
            .AppendLine("#nullable disable warnings")
            .AppendLine()
            .AppendLine("// Suppress warnings about [Obsolete] member usage in generated code.")
            .AppendLine("#pragma warning disable CS0612, CS0618")
            .AppendLine()
            .AppendLine("namespace Splat")
            .AppendLine("{")
            .AppendLine($"    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{_assemblyName.Name}\", \"{_assemblyName.Version}\")]")
            .AppendLine("    internal static partial class SplatRegistrations")
            .AppendLine("    {")
            .AppendLine("        static partial void SetupIOCInternal(Splat.IDependencyResolver resolver)")
            .AppendLine("        {");

        // Generate transient registrations
        foreach (var registration in transients)
        {
            GenerateTransientRegistration(sb, registration);
        }

        // Generate lazy singleton registrations
        foreach (var registration in lazySingletons)
        {
            GenerateLazySingletonRegistration(sb, registration);
        }

        sb.AppendLine("        }")
            .AppendLine("    }")
            .AppendLine("}");

        return sb.ToString();
    }

    internal static void GenerateTransientRegistration(
        StringBuilder sb,
        TransientRegistrationInfo registration)
    {
        // Build constructor arguments - resolve from resolver with null checks
        var args = new string[registration.ConstructorParameters.Length];
        for (var i = 0; i < registration.ConstructorParameters.Length; i++)
        {
            var p = registration.ConstructorParameters[i];

            // Handle IEnumerable<T> - use GetServices<T>()
            if (p.IsCollection && p.CollectionItemType is not null)
            {
                // GetServices<T>() returns IEnumerable<T>, never null (empty collection instead)
                if (registration.ContractValue is not null)
                {
                    args[i] = $"resolver.GetServices<{p.CollectionItemType}>({registration.ContractValue})";
                }
                else
                {
                    args[i] = $"resolver.GetServices<{p.CollectionItemType}>()";
                }
            }
            else
            {
                // Use generic GetService<T>() - no cast needed, better for AOT
                if (registration.ContractValue is not null)
                {
                    args[i] = $"resolver.GetService<{p.TypeFullName}>({registration.ContractValue}) ?? throw new global::System.InvalidOperationException(\"Dependency '{p.TypeFullName}' with contract {registration.ContractValue} not registered with Splat resolver.\")";
                }
                else
                {
                    args[i] = $"resolver.GetService<{p.TypeFullName}>() ?? throw new global::System.InvalidOperationException(\"Dependency '{p.TypeFullName}' not registered with Splat resolver.\")";
                }
            }
        }

        var constructorArgs = string.Join(", ", args);

        // Build property initializer if needed
        string? propertyInitializer = null;
        if (registration.PropertyInjections.Length > 0)
        {
            var props = new string[registration.PropertyInjections.Length];
            for (var i = 0; i < registration.PropertyInjections.Length; i++)
            {
                var p = registration.PropertyInjections[i];

                // Use generic GetService<T>() - no cast needed, better for AOT
                if (registration.ContractValue is not null)
                {
                    props[i] = $"{p.PropertyName} = resolver.GetService<{p.TypeFullName}>({registration.ContractValue}) ?? throw new global::System.InvalidOperationException(\"Dependency '{p.TypeFullName}' with contract {registration.ContractValue} not registered with Splat resolver.\")";
                }
                else
                {
                    props[i] = $"{p.PropertyName} = resolver.GetService<{p.TypeFullName}>() ?? throw new global::System.InvalidOperationException(\"Dependency '{p.TypeFullName}' not registered with Splat resolver.\")";
                }
            }

            var properties = string.Join(", ", props);
            propertyInitializer = $" {{ {properties} }}";
        }

        // Build contract parameter
        var contractArg = registration.ContractValue is not null
            ? $", {registration.ContractValue}"
            : string.Empty;

        // Generate: resolver.Register<IInterface>(() => new Concrete(...) { Props... })
        sb.Append($"            resolver.Register<{registration.InterfaceTypeFullName}>(")
            .Append($"() => new {registration.ConcreteTypeFullName}({constructorArgs})")
            .Append(propertyInitializer ?? string.Empty)
            .AppendLine($"{contractArg});");
    }

    internal static void GenerateLazySingletonRegistration(
        StringBuilder sb,
        LazySingletonRegistrationInfo registration)
    {
        sb.AppendLine("            {");

        // Build constructor arguments
        var args = new string[registration.ConstructorParameters.Length];
        for (var i = 0; i < registration.ConstructorParameters.Length; i++)
        {
            var p = registration.ConstructorParameters[i];

            // Handle IEnumerable<T> - use GetServices<T>()
            if (p.IsCollection && p.CollectionItemType is not null)
            {
                // GetServices<T>() returns IEnumerable<T>, never null (empty collection instead)
                if (registration.ContractValue is not null)
                {
                    args[i] = $"resolver.GetServices<{p.CollectionItemType}>({registration.ContractValue})";
                }
                else
                {
                    args[i] = $"resolver.GetServices<{p.CollectionItemType}>()";
                }
            }
            else
            {
                // Use generic GetService<T>() - no cast needed, better for AOT
                if (registration.ContractValue is not null)
                {
                    args[i] = $"resolver.GetService<{p.TypeFullName}>({registration.ContractValue}) ?? throw new global::System.InvalidOperationException(\"Dependency '{p.TypeFullName}' with contract {registration.ContractValue} not registered with Splat resolver.\")";
                }
                else
                {
                    args[i] = $"resolver.GetService<{p.TypeFullName}>() ?? throw new global::System.InvalidOperationException(\"Dependency '{p.TypeFullName}' not registered with Splat resolver.\")";
                }
            }
        }

        var constructorArgs = string.Join(", ", args);

        // Build property initializer
        string? propertyInitializer = null;
        if (registration.PropertyInjections.Length > 0)
        {
            var props = new string[registration.PropertyInjections.Length];
            for (var i = 0; i < registration.PropertyInjections.Length; i++)
            {
                var p = registration.PropertyInjections[i];

                // Use generic GetService<T>() - no cast needed, better for AOT
                if (registration.ContractValue is not null)
                {
                    props[i] = $"{p.PropertyName} = resolver.GetService<{p.TypeFullName}>({registration.ContractValue}) ?? throw new global::System.InvalidOperationException(\"Dependency '{p.TypeFullName}' with contract {registration.ContractValue} not registered with Splat resolver.\")";
                }
                else
                {
                    props[i] = $"{p.PropertyName} = resolver.GetService<{p.TypeFullName}>() ?? throw new global::System.InvalidOperationException(\"Dependency '{p.TypeFullName}' not registered with Splat resolver.\")";
                }
            }

            var properties = string.Join(", ", props);
            propertyInitializer = $" {{ {properties} }}";
        }

        // Create lazy instance
        var lazyTypeFullName = $"global::System.Lazy<{registration.InterfaceTypeFullName}>";
        var lazyModeArg = registration.LazyThreadSafetyMode is not null
            ? $", {registration.LazyThreadSafetyMode}"
            : string.Empty;

        sb.Append($"                {lazyTypeFullName} lazy = ")
            .Append($"new {lazyTypeFullName}(")
            .Append($"() => new {registration.ConcreteTypeFullName}({constructorArgs})")
            .Append(propertyInitializer ?? string.Empty)
            .AppendLine($"{lazyModeArg});");

        // Build contract parameter
        var contractArg = registration.ContractValue is not null
            ? $", {registration.ContractValue}"
            : string.Empty;

        // Register both Lazy<T> and T
        sb.AppendLine($"                resolver.Register<{lazyTypeFullName}>(() => lazy{contractArg});")
            .AppendLine($"                resolver.Register<{registration.InterfaceTypeFullName}>(() => lazy.Value{contractArg});")
            .AppendLine("            }");
    }

    private static TransientRegistrationInfo? ExtractRegisterMetadata(
        GeneratorSyntaxContext context,
        CancellationToken ct)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get method symbol
        if (semanticModel.GetSymbolInfo(invocation, ct).Symbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        // Verify it's SplatRegistrations.Register
        if (!RoslynHelpers.IsSplatRegistrationsMethod(methodSymbol, "Register"))
        {
            return null;
        }

        // Extract type arguments (1 or 2)
        var numberTypeParameters = methodSymbol.TypeArguments.Length;
        if (numberTypeParameters is 0 or > 2)
        {
            return null;
        }

        var interfaceType = methodSymbol.TypeArguments[0];
        var concreteType = numberTypeParameters == 2
            ? methodSymbol.TypeArguments[1]
            : interfaceType;

        // Convert ISymbol → POCO (NO ISymbol references in result!)
        var constructorParams = ExtractConstructorParameters(concreteType, invocation.GetLocation());
        if (constructorParams == null)
        {
            return null; // Invalid constructor, silently skip
        }

        var propertyInjections = ExtractPropertyInjections(concreteType);
        if (propertyInjections == null)
        {
            return null; // Invalid properties, silently skip
        }

        var contractValue = RoslynHelpers.ExtractContractParameter(methodSymbol, invocation, semanticModel, ct);

        return new TransientRegistrationInfo(
            InterfaceTypeFullName: interfaceType.ToDisplayString(_fullyQualifiedFormat),
            ConcreteTypeFullName: concreteType.ToDisplayString(_fullyQualifiedFormat),
            ConstructorParameters: new EquatableArray<ConstructorParameter>(constructorParams),
            PropertyInjections: new EquatableArray<PropertyInjection>(propertyInjections),
            ContractValue: contractValue,
            InvocationLocation: invocation.GetLocation());
    }

    private static LazySingletonRegistrationInfo? ExtractLazySingletonMetadata(
        GeneratorSyntaxContext context,
        CancellationToken ct)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get method symbol
        if (semanticModel.GetSymbolInfo(invocation, ct).Symbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        // Verify it's SplatRegistrations.RegisterLazySingleton
        if (!RoslynHelpers.IsSplatRegistrationsMethod(methodSymbol, "RegisterLazySingleton"))
        {
            return null;
        }

        // Extract type arguments (1 or 2)
        var numberTypeParameters = methodSymbol.TypeArguments.Length;
        if (numberTypeParameters is 0 or > 2)
        {
            return null;
        }

        var interfaceType = methodSymbol.TypeArguments[0];
        var concreteType = numberTypeParameters == 2
            ? methodSymbol.TypeArguments[1]
            : interfaceType;

        // Convert ISymbol → POCO (NO ISymbol references in result!)
        var constructorParams = ExtractConstructorParameters(concreteType, invocation.GetLocation());
        if (constructorParams == null)
        {
            return null; // Invalid constructor, silently skip
        }

        var propertyInjections = ExtractPropertyInjections(concreteType);
        if (propertyInjections == null)
        {
            return null; // Invalid properties, silently skip
        }

        var contractValue = RoslynHelpers.ExtractContractParameter(methodSymbol, invocation, semanticModel, ct);
        var lazyMode = RoslynHelpers.ExtractLazyThreadSafetyMode(methodSymbol, invocation, semanticModel, ct);

        return new LazySingletonRegistrationInfo(
            InterfaceTypeFullName: interfaceType.ToDisplayString(_fullyQualifiedFormat),
            ConcreteTypeFullName: concreteType.ToDisplayString(_fullyQualifiedFormat),
            ConstructorParameters: new EquatableArray<ConstructorParameter>(constructorParams),
            PropertyInjections: new EquatableArray<PropertyInjection>(propertyInjections),
            ContractValue: contractValue,
            LazyThreadSafetyMode: lazyMode,
            InvocationLocation: invocation.GetLocation());
    }

    private static ConstructorParameter[]? ExtractConstructorParameters(ITypeSymbol concreteType, Location invocationLocation)
    {
        // Manual loop with single-pass filtering (eliminates 3 LINQ allocations per registration)
        var members = concreteType.GetMembers();
        var constructors = new List<IMethodSymbol>(capacity: 4); // Most types have 1-4 ctors

        for (var i = 0; i < members.Length; i++)
        {
            if (members[i] is IMethodSymbol { MethodKind: MethodKind.Constructor, IsStatic: false } ctor)
            {
                constructors.Add(ctor);
            }
        }

        var constructorCount = constructors.Count;

        IMethodSymbol? selectedConstructor = null;

        if (constructorCount == 1)
        {
            selectedConstructor = constructors[0];
        }
        else if (constructorCount > 1)
        {
            // Find constructor with attribute (manual loop to avoid LINQ allocation)
            for (var i = 0; i < constructorCount; i++)
            {
                var constructor = constructors[i];
                var attrs = constructor.GetAttributes();
                var hasAttribute = false;

                for (var j = 0; j < attrs.Length; j++)
                {
                    if (attrs[j].AttributeClass?.ToDisplayString(_fullyQualifiedFormat) == Constants.ConstructorAttribute)
                    {
                        hasAttribute = true;
                        break;
                    }
                }

                if (hasAttribute)
                {
                    if (selectedConstructor != null)
                    {
                        // Multiple constructors marked - silently skip (analyzer will warn)
                        return null;
                    }

                    selectedConstructor = constructor;
                }
            }

            if (selectedConstructor == null)
            {
                // Multiple constructors, none marked - silently skip (analyzer will warn)
                return null;
            }
        }

        if (selectedConstructor == null)
        {
            return [];
        }

        // Check accessibility
        if (selectedConstructor.DeclaredAccessibility < Accessibility.Internal)
        {
            return null; // Private/protected constructor - silently skip
        }

        // Extract parameters (pre-allocate with exact capacity to avoid resizing)
        var parameters = new List<ConstructorParameter>(selectedConstructor.Parameters.Length);
        foreach (var param in selectedConstructor.Parameters)
        {
            var paramType = param.Type;
            var paramTypeName = paramType.ToDisplayString(_fullyQualifiedFormat);

            // Check if it's Lazy<T>
            bool isLazy = false;
            string? lazyInnerType = null;

            if (paramType is INamedTypeSymbol namedType &&
                namedType.OriginalDefinition.ToDisplayString(_fullyQualifiedFormat) == "global::System.Lazy<T>")
            {
                isLazy = true;
                if (namedType.TypeArguments.Length > 0)
                {
                    lazyInnerType = namedType.TypeArguments[0].ToDisplayString(_fullyQualifiedFormat);
                }
            }

            // Check if it's IEnumerable<T>
            bool isCollection = false;
            string? collectionItemType = null;

            if (paramType is INamedTypeSymbol namedCollType &&
                namedCollType.OriginalDefinition.ToDisplayString(_fullyQualifiedFormat) == "global::System.Collections.Generic.IEnumerable<T>")
            {
                isCollection = true;
                if (namedCollType.TypeArguments.Length > 0)
                {
                    collectionItemType = namedCollType.TypeArguments[0].ToDisplayString(_fullyQualifiedFormat);
                }
            }

            parameters.Add(new ConstructorParameter(
                ParameterName: param.Name,
                TypeFullName: paramTypeName,
                IsLazy: isLazy,
                LazyInnerType: lazyInnerType,
                IsCollection: isCollection,
                CollectionItemType: collectionItemType));
        }

        return parameters.ToArray();
    }

    private static PropertyInjection[]? ExtractPropertyInjections(ITypeSymbol concreteType)
    {
        // Estimate capacity based on typical inheritance depth (2-5 properties common)
        var properties = new List<PropertyInjection>(capacity: 4);

        // Get all properties from base types and this type
        var allTypes = RoslynHelpers.GetBaseTypesAndThis(concreteType);

        foreach (var type in allTypes)
        {
            foreach (var member in type.GetMembers())
            {
                if (member is not IPropertySymbol property)
                {
                    continue;
                }

                // Check for DependencyInjectionProperty attribute (manual loop to avoid LINQ allocation)
                var attrs = property.GetAttributes();
                var hasAttribute = false;

                for (var i = 0; i < attrs.Length; i++)
                {
                    if (attrs[i].AttributeClass?.ToDisplayString(_fullyQualifiedFormat) == Constants.PropertyAttribute)
                    {
                        hasAttribute = true;
                        break;
                    }
                }

                if (!hasAttribute)
                {
                    continue;
                }

                // Validate setter accessibility
                if (property.SetMethod == null || property.SetMethod.DeclaredAccessibility < Accessibility.Internal)
                {
                    return null; // Invalid property - silently skip (analyzer will warn)
                }

                properties.Add(new PropertyInjection(
                    PropertyName: property.Name,
                    TypeFullName: property.Type.ToDisplayString(_fullyQualifiedFormat),
                    PropertyLocation: property.Locations.Length > 0 ? property.Locations[0] : Location.None));
            }
        }

        return properties.ToArray();
    }
}
